<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Python作为一门多范式编程语言，也提供了对函数式编程（Functional Programming）的支持，虽然并不是那么纯粹，也不支持尾递归优化......"/>




  <meta name="keywords" content="python,函数式编程," />




  <link rel="alternate" href="/atom.xml" title="Sika">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://sikasjc.github.io/2018/06/15/iterator-generator/"/>


<meta name="description" content="Python作为一门多范式编程语言，也提供了对函数式编程（Functional Programming）的支持，虽然并不是那么纯粹，也不支持尾递归优化......">
<meta name="keywords" content="python,函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Python HOWTOS学习，函数式编程（一）">
<meta property="og:url" content="http://sikasjc.github.io/2018/06/15/iterator-generator/index.html">
<meta property="og:site_name" content="Sika">
<meta property="og:description" content="Python作为一门多范式编程语言，也提供了对函数式编程（Functional Programming）的支持，虽然并不是那么纯粹，也不支持尾递归优化......">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-06-15T04:44:17.466Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python HOWTOS学习，函数式编程（一）">
<meta name="twitter:description" content="Python作为一门多范式编程语言，也提供了对函数式编程（Functional Programming）的支持，虽然并不是那么纯粹，也不支持尾递归优化......">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />







<script>
  var CONFIG = {
    search: ,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  



    <title> Python HOWTOS学习，函数式编程（一） · Sika </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Sika</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Sika</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Python HOWTOS学习，函数式编程（一）
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018年6月15日
        </span>
      </div>
        
          <div class="post-tags">
            
              <a href="/tags/python/">python</a>
            
              <a href="/tags/函数式编程/">函数式编程</a>
            
          </div>
        
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduction"><span class="toc-number">1.</span> <span class="toc-text"> Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterators-迭代器"><span class="toc-number">2.</span> <span class="toc-text"> Iterators 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#支持迭代器的数据结构"><span class="toc-number">2.1.</span> <span class="toc-text"> 支持迭代器的数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生成器和list"><span class="toc-number">3.</span> <span class="toc-text"> 生成器和list</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器-generators"><span class="toc-number">3.1.</span> <span class="toc-text"> 生成器 Generators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传值给生成器-passing-values-into-a-generator"><span class="toc-number">3.2.</span> <span class="toc-text"> 传值给生成器 Passing values into a generator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-number">4.</span> <span class="toc-text"> Reference</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>Python作为一门多范式编程语言，也提供了对函数式编程（Functional Programming）的支持，虽然并不是那么纯粹，也不支持尾递归优化。文档讲述了Python在函数式编程方面的支持与语言特性，例如<code>iterators</code>, <code>generators</code>以及相关的库<code>itertools</code>和<code>functools</code>。</p>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2>
<p>什么是函数式编程，Functional Programming？</p>
<p>编程语言可以分为以下几种：</p>
<ul>
<li>面向过程：程序直接告诉计算机如何处理程序输入的指令列表，C、Pascal甚至Unix shell都是面向过程的编程语言。</li>
<li>在声明性语言（declarative languages）中，编写了一个描述要解决的问题的规范，并且编程语言的实现，指出了如何高效地执行计算。SQL应该是最有名的声明性语言。</li>
<li>面向对象：程序处理对象的集合。对象具有自己的内部状态，并且具有支持查询或修改此内部状态方法。Smalltalk和Java是面向对象的编程语言，C++和Python也是支持面向对象编程的语言，但不强制使用面向对象编程范式。</li>
<li>函数式编程将问题分解为一组函数。理想情况下，函数只接收输入并产生输出，并且函数的内部状态不会影响给定输入产生的输出。这也是函数式编程的一大优势，即<strong>Immutable Data（数据不可变）</strong>。简而言之，<strong>不依赖于外部的数据，而且也不改变外部数据的值</strong>，这种思想可以大大减少代码中的Bug，并且函数式编程也支持<strong>像使用变量一样使用函数</strong>。函数式语言包括 ML family (Standard ML, OCaml, and other variants)和Haskell。</li>
</ul>
<p>函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。因此，任意一个函数，只要输入是确定的，输出就是确定的，即每个函数的输出只能依赖于它的输入。这种纯函数（purely functional）我们称之为没有副作用 (side effect)。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程可以被认为是面向对象编程的反面。对象是包含内部状态以及允许修改此状态的方法的集合，而函数式编程希望处理数据流时，尽可能避免状态变化。</p>
<p>一些编程语言对纯度（purity）非常严格，甚至没有赋值语句，如<code>a = 3</code>或<code>c = a + b</code>，但副作用很难避免。例如，打印到屏幕或写入磁盘文件是有副作用的。在Python中，对<code>print()</code>或<code>time.sleep()</code>函数的调用都不会返回有用的值，它们只会发送一些文字到屏幕或暂停执行一秒钟的副作用。</p>
<p>那么为什么要采用函数式编程的范式？为什么要避免对象和副作用？</p>
<p>函数式编程有着理论和实践上的优势：</p>
<ul>
<li>Formal provability 简而言之，相对易于在数学上证明函数是正确的</li>
<li>Modularity 这种范式迫使必须将问题分解，程序因此更模块化。</li>
<li>Composability</li>
<li>Ease of debugging and testing</li>
</ul>
<p>我们可以不用极端的使用函数式编程，而是使函数的接口使用近似于函数式的风格，在内部使用非函数式范式。例如，函数的实现仍然赋值给局部变量，但不会修改全局变量或有其他副作用。</p>
<p>函数式编程的令一个特点是<strong>允许把函数本身作为参数传入另一个函数，甚至允许返回一个函数。</strong></p>
<p>这样我们可以总结下面对对象编程和函数式编程：</p>
<p>面对对象的：</p>
<ul>
<li>数据和对数据的操作紧紧耦合</li>
<li>对象隐藏它们操作的实现细节，其他对象调用这些操作只需要通过接口。</li>
<li>核心抽象模型是数据自己</li>
<li>核心活动是组合新对象和拓展已经存在的对象，这是通过加入新的方法实现的。</li>
</ul>
<p>函数式编程：</p>
<ul>
<li>数据与函数是松耦合的</li>
<li>函数隐藏了它们的实现，语言的抽象是函数，以及将函数组合起来表达。</li>
<li>核心抽象模型是函数，不是数据结构</li>
<li>核心活动是编写新的函数。</li>
<li>变量缺省是不变的，减少可变性变量的使用，并发性好</li>
</ul>
<h2 id="iterators-迭代器"><a class="markdownIt-Anchor" href="#iterators-迭代器"></a> Iterators 迭代器</h2>
<p>我们从Python语言特征中支持函数式编程的重要基础 <code>Iterable</code> 和 Iterator 迭代器开始。</p>
<p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>，Python的一些内置数据类型支持迭代，最常见的是list和dictionary。我们可以使用Python标准库collections和<code>isinstance</code>来判断一个对象是否是<code>Iterable</code>的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>]), Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>而迭代器是一个表示数据流的对象，这个对象一次返回一个元素的数据。Python迭代器不但可以作用于<code>for</code>循环 ，且可以被<code>next()</code>函数调用并不断返回下一个值，即必须支持名为<code>__next__()</code>的方法，该方法不接受任何参数，并且始终返回数据流的下一个元素。如果数据流中没有更多元素，<code>__next__()</code>必须抛出StopIteration异常。</p>
<p>因此，迭代器不一定是有限的，编写一个能够产生无限数据流的迭代器是完全有可能的。</p>
<p>内置(built-in)<code>iter()</code>函数接受任意对象，并尝试返回一个将返回对象内容或元素的迭代器，如果该对象不支持迭代，则引发TypeError。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it  </span><br><span class="line">&lt;...iterator object at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.__next__()  <span class="comment"># same as next(it)</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>同时可以通过<code>list()</code>，<code>tuple()</code>等函数将迭代器转为list、tuple等对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(iterator)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>序列解包（sequence unpacking ）也支持迭代器，知道迭代器将返回N个元素，则可以将它们解包为N元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iterator = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,c = iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>isinstance()</code>判断一个对象是否是迭代器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>诸如<code>max()</code>和<code>min()</code>之类的内置函数可以接受一个迭代器参数，并返回最大或最小的元素。&quot;in&quot;和&quot;not in&quot;运算符也支持迭代器：如果可以在迭代器返回的流中找到X，则<code>X in iterator</code>为<code>true</code>。</p>
<p>如果迭代器是无限的，则<code>max()</code>，<code>min()</code>自然无返回值，如果元素X从不出现在流中，那么&quot;in&quot;和&quot;not in&quot;运算符也无返回。</p>
<p>**注意，在迭代器中只能前进。**没有办法获得前一个元素，也不能重置迭代器或生成迭代器的原始副本。</p>
<p>迭代器对象可以选择提供些额外的功能，但迭代器协议仅指定<code>__next __()</code>方法。因此函数可能会消耗迭代器的所有输出，并且如果您需要对同一个流执行不同的操作，则必须创建一个新的迭代器。</p>
<h3 id="支持迭代器的数据结构"><a class="markdownIt-Anchor" href="#支持迭代器的数据结构"></a> 支持迭代器的数据结构</h3>
<p><code>list</code>、<code>dict</code>、<code>tuple</code>支持迭代器。 实际上，任何一个Python序列类型（如字符串）都支持创建迭代器。在<code>dict</code>上调用<code>iter()</code>会返回一个遍历<code>dict</code>中<code>key</code>的迭代器：</p>
<blockquote>
<p>实际上这里<code>for key in iter(m)</code>和<code>for key in m</code>是等价的，因为<code>dict</code>也是<code>Iterable</code>。顺序基本上是随机的，因为基于<code>dict</code>中对象的哈希排序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = &#123;<span class="string">'Jan'</span>: <span class="number">1</span>, <span class="string">'Feb'</span>: <span class="number">2</span>, <span class="string">'Mar'</span>: <span class="number">3</span>, <span class="string">'Apr'</span>: <span class="number">4</span>, <span class="string">'May'</span>: <span class="number">5</span>, <span class="string">'Jun'</span>: <span class="number">6</span>,</span><br><span class="line"><span class="meta">... </span>     <span class="string">'Jul'</span>: <span class="number">7</span>, <span class="string">'Aug'</span>: <span class="number">8</span>, <span class="string">'Sep'</span>: <span class="number">9</span>, <span class="string">'Oct'</span>: <span class="number">10</span>, <span class="string">'Nov'</span>: <span class="number">11</span>, <span class="string">'Dec'</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> iter(m):  </span><br><span class="line"><span class="meta">... </span>    print(key, m[key])</span><br><span class="line">Mar <span class="number">3</span></span><br><span class="line">Feb <span class="number">2</span></span><br><span class="line">Aug <span class="number">8</span></span><br><span class="line">Sep <span class="number">9</span></span><br><span class="line">Apr <span class="number">4</span></span><br><span class="line">Jun <span class="number">6</span></span><br><span class="line">Jul <span class="number">7</span></span><br><span class="line">Jan <span class="number">1</span></span><br><span class="line">May <span class="number">5</span></span><br><span class="line">Nov <span class="number">11</span></span><br><span class="line">Dec <span class="number">12</span></span><br><span class="line">Oct <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>文件还通过调用<code>readline()</code>方法来迭代，直到文件中没有行。</p>
<p>迭代器对象都是<code>Iterable</code>，但<code>list</code>、<code>dict</code>、<code>str</code>、<code>tuple</code>、<code>set</code>虽然是<code>Iterable</code>，却不是迭代器。</p>
<p>可以从这个角度理解：迭代器不一定是有限的，<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算，因此编写一个能够产生无限数据流的迭代器是完全有可能的，而无限长的<code>list</code>，<code>dict</code>，<code>str</code>，<code>tuple</code>、<code>set</code>是不存在的。</p>
<h2 id="生成器和list"><a class="markdownIt-Anchor" href="#生成器和list"></a> 生成器和list</h2>
<p>对于一个迭代器输出，会有一些常见操作：</p>
<ul>
<li>对每个元素执行一些操作</li>
<li>选择满足某些条件的元素子集</li>
</ul>
<p>这些操作可以称为列表生成式和生成器表达式（List comprehensions and generator expressions），简写为：“listcomps&quot;和&quot;genexps”。生成器表达式由圆括号<code>()</code>包裹，列表生成式由方括号<code>[]</code>包裹。</p>
<p>例如，给定一个字符串列表，删除每行尾部的空白或提取包含给定子字符串的所有字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line_list = [<span class="string">'  line 1\n'</span>, <span class="string">'line 2  \n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generator expression -- returns iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stripped_iter = (line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> line_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stripped_iter</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x000001B1E9FF1F68</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># List comprehension -- returns list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stripped_list = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> line_list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stripped_list</span><br><span class="line">[<span class="string">'line 1'</span>, <span class="string">'line 2'</span>]</span><br></pre></td></tr></table></figure>
<p>也可以使用&quot;if&quot;语句来选择某些元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stripped_list = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> line_list</span><br><span class="line">                 <span class="keyword">if</span> line != <span class="string">""</span>]</span><br></pre></td></tr></table></figure>
<p>通过列表生成式(list comprehension)，可以得到一个Python <code>list</code>，即stripped_list返回的是包含结果行的<code>list</code>，而不是迭代器。生成器表达式(generator expressions)返回一个迭代器，根据需要计算值，而不需要一次实现所有值。</p>
<p>这意味着如果返回无限流或非常大量数据的迭代器时，应使用生成器表达式。</p>
<p>下面是一个典型的生成器表达式，列表生成式只需将<code>()</code>换位<code>[]</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">( expression <span class="keyword">for</span> expr <span class="keyword">in</span> sequence1</span><br><span class="line">             <span class="keyword">if</span> condition1</span><br><span class="line">             <span class="keyword">for</span> expr2 <span class="keyword">in</span> sequence2</span><br><span class="line">             <span class="keyword">if</span> condition2</span><br><span class="line">             <span class="keyword">for</span> expr3 <span class="keyword">in</span> sequence3 ...</span><br><span class="line">             <span class="keyword">if</span> condition3</span><br><span class="line">             <span class="keyword">for</span> exprN <span class="keyword">in</span> sequenceN</span><br><span class="line">             <span class="keyword">if</span> conditionN )</span><br></pre></td></tr></table></figure>
<p>实际上，上面的列表生成式或生成器表达式等同于以下Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> expr1 <span class="keyword">in</span> sequence1:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (condition1):</span><br><span class="line">        <span class="keyword">continue</span>   <span class="comment"># Skip this element</span></span><br><span class="line">    <span class="keyword">for</span> expr2 <span class="keyword">in</span> sequence2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (condition2):</span><br><span class="line">            <span class="keyword">continue</span>   <span class="comment"># Skip this element</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> exprN <span class="keyword">in</span> sequenceN:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (conditionN):</span><br><span class="line">                <span class="keyword">continue</span>   <span class="comment"># Skip this element</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Output the value of</span></span><br><span class="line">            <span class="comment"># the expression.</span></span><br></pre></td></tr></table></figure>
<p>生成器表达式必须写在圆括号中，但用于函数调用的括号也会被计数。因此，创建一个将被立即传递给函数的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj_total = sum(obj.count <span class="keyword">for</span> obj <span class="keyword">in</span> list_all_objects())</span><br></pre></td></tr></table></figure>
<p>同时注意到，为了避免在Python语法中引入歧义，如果表达式创建一个元组，它必须用圆括号包裹。下面的第一个列表生成式语法错误，第二个正确：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Syntax error</span></span><br><span class="line">[x, y <span class="keyword">for</span> x <span class="keyword">in</span> seq1 <span class="keyword">for</span> y <span class="keyword">in</span> seq2]</span><br><span class="line"><span class="comment"># Correct</span></span><br><span class="line">[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> seq1 <span class="keyword">for</span> y <span class="keyword">in</span> seq2]</span><br></pre></td></tr></table></figure>
<h3 id="生成器-generators"><a class="markdownIt-Anchor" href="#生成器-generators"></a> 生成器 Generators</h3>
<p>生成器是一类特殊的函数，可以简化编写迭代器的任务。一般的函数计算一个值并将其返回，但生成器返回一个迭代器，这个迭代器返回一个数据流。</p>
<p>在Python中，调用一个函数时，它会得到一个私有命名空间，其中创建了局部变量。当函数到达return语句时，局部变量将被销毁，并且该值将返回给调用者。之后调用相同的函数将创建一个新的私有命名空间和一组新的局部变量。</p>
<p>但是，如何使局部变量在退出函数时不被销毁？如何恢复到之前调用函数离开时的位置？这正是生成器所提供的功能。</p>
<p>如下是生成器的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">generate_ints</span><span class="params">(N)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p>任何包含<code>yield</code>关键字的函数都是生成器函数，由Python的字节码编译器负责检测，该编译器专门编译该函数。</p>
<p>当调用生成器函数时，它不会返回单个值，相反，返回一个支持迭代器协议的生成器对象。</p>
<p>在执行<code>yield</code>表达式时，生成器输出<code>i</code>的值，类似于<code>return</code>语句。<code>yield</code>与<code>return</code>语句之间的差异在于，在达到<code>yield</code>时，生成器的执行状态将暂停并保留局部变量。当下一次调用生成器的<code>__next__()</code>方法时，函数将继续执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = generate_ints(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen  </span><br><span class="line">&lt;generator object generate_ints at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"stdin"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"stdin"</span>, line <span class="number">2</span>, <span class="keyword">in</span> generate_ints</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于<code>for i in generate_ints(5)</code>或<code>a, b, c = generate_ints(3)</code>。</p>
<p>Python库 <a href="Lib/test/test_generators.py">Lib/test/test_generators.py</a> 中包含许多更有趣的示例。下面一个使用递归实现树的按中序遍历的生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A recursive generator that generates Tree leaves in in-order.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> t:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> inorder(t.left):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> t.label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> inorder(t.right):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>
<p><code>test_generators.py</code>中的另外两个例子实现了N-Queens问题（将N个皇后放置在NxN棋盘上，并保证一个皇后不会威胁到另一个皇后）和骑士之旅（在NxN棋盘中，骑士寻找不重复到达的每个方格的路线）。</p>
<h3 id="传值给生成器-passing-values-into-a-generator"><a class="markdownIt-Anchor" href="#传值给生成器-passing-values-into-a-generator"></a> 传值给生成器 Passing values into a generator</h3>
<p>在Python2.5及以后，可以将值简单的传递到生成器。<code>yield</code>成为一个表达式，返回一个可以赋值给一个变量或以其他方式运行的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = (<span class="keyword">yield</span> i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议在使用返回的值进行操作时，总是用<code>()</code>包裹yield表达式，如上例所示。</p>
</blockquote>
<blockquote>
<p>在<a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener">PEP 342</a>解释了这个规则，即一个yield-expression必须总是被加上括号，除非它出现在赋值右边的顶级表达式上，如<code>val = yield i</code>，但在有操作时使用括号，如<code>val =（yield i）+ 12</code>。</p>
</blockquote>
<p>通过调用<code>send(value)</code>方法，可以将值传至生成器中。此方法恢复执行生成器的代码，且<code>yield</code>表达式返回指定的值。 如果调用<code>__next__()</code>方法，则<code>yield</code>返回<code>None</code>。</p>
<p>这里有一个简单的计数器，递增1并允许更改内部计数器的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(maximum)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; maximum:</span><br><span class="line">        val = (<span class="keyword">yield</span> i)</span><br><span class="line">        <span class="comment"># If value provided, change counter</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            i = val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>更改计数器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = counter(<span class="number">10</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.send(<span class="number">8</span>)  </span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)  </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"t.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    it.next()</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>因为<code>yield</code>通常会返回<code>None</code>，所以应该经常检查这个情况。除非确定<code>send()</code>方法将是唯一用于恢复生成器函数的方法，否则不要在表达式中使用。</p>
<p>除了<code>send()</code>，还有其他两个发生器方法</p>
<ul>
<li><code>throw(type，value = None，traceback = None)</code>用于在生成器内引发异常。生成器执行暂停时的<code>yield</code>表达式引发异常，之后会继续执行生成器对象中后面的语句，直至遇到下一个<code>yield</code>语句返回。如果在生成器对象方法执行完毕后，依然没有遇到<code>yield</code>语句，抛出<code>StopIteration</code>异常。</li>
<li><code>close()</code>在生成器中引发一个<code>GeneratorExit</code>异常来终止迭代。在收到此异常时，生成器的代码必须抛出<code>GeneratorExit</code>或<code>StopIteration</code>，捕获异常并执行其他任何操作都是非法的，并且会触发RuntimeError。 当生成器销毁时，<code>close()</code>也将被Python的垃圾回收调用。</li>
</ul>
<blockquote>
<p>如果需要在发生<code>GeneratorExit</code>时运行清理代码，建议使用<code>try：... finally：,</code>而不是捕获<code>GeneratorExit</code>。</p>
</blockquote>
<p>有了这些方法，将生成器从“一个单向信息生产者”转变为“一个生产者和消费者”。</p>
<p>生成器也成为了协程（<strong>coroutines</strong>），这是一种更普遍的子程序形式。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。</p>
<p>而协程的调用和子程序不同。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ol>
<li>Python官方文档：<a href="https://docs.python.org/3/howto/index.html" target="_blank" rel="noopener">Python HOWTOs</a></li>
<li><a href="http://www.jdon.com/functional.html" target="_blank" rel="noopener">面向函数范式编程(Functional programming)</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰Python教程</a></li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>Sikasjc</span>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://sikasjc.github.io/2018/06/15/iterator-generator/">http://sikasjc.github.io/2018/06/15/iterator-generator/</a>
    </p>
    <p class="copyright-item lincese">
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/python/">python</a>
            
              <a href="/tags/函数式编程/">函数式编程</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/06/20/list-and-tuple/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Python数据类型：list 与 tuple 的区别</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2018/06/12/NMS/">
        <span class="next-text nav-default">Non-Maximum Suppression（NMS）非最大抑制</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzQzMy85OTg5">
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>  
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:sikasjc@163.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/sikasjc" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://weibo.com/u/5605720030" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a href="https://www.zhihu.com/people/si-qia-sika" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Sikasjc</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  
   <script type="text/javascript">
	(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  </body>
</html>
